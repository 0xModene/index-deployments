import path from "path";
import chalk from "chalk";
import { bufferToHex, keccakFromString } from "ethereumjs-util";
import * as ethersABI from "@ethersproject/abi";
import { task, extendEnvironment } from "hardhat/config";
import { HardhatRuntimeEnvironment as HRE } from "hardhat/types";

import { log } from "../deployments/utils/deploys/outputHelper";
import { default as dependencyAddresses } from "../deployments/utils/deploys/dependencies";

const etherscan = require("etherscan-api");
const DiffMatchPatch = require("diff-match-patch");

// =================
// Session Variables
// =================
const addressesPath = path.join(process.cwd(), "deployments/outputs/1-production.json");
const systemAddresses = require(addressesPath).addresses;
const defaultFile = process.env.TESTING_PRODUCTION ? "50-development" : "1-production";
let destinationMap: any;

// =======
// Strings
// =======

const list = "lists all deferred transactions by transaction number with description";
const view = "shows detail for a deferred transaction";
const compare = "checks that tx data at `tx-num` matches `data` (from wallet)";
const file = "`deployments/outputs/*.json` file to query (defaults: `1-production`)";

const methodsHelp = `"set.methods(contract: string)" - lists methods for a contract`;
const recentHelp = `"await set.recent(maxRecords? : number)" - shows recent multisig txs from Etherscan`;
const addressesHelp = `"set.addresses" - lists system & dependency addresses`;
const getAddressNameHelp = `"set.getAddressName(addr: string) - shows human-readable alias for addr`;

const addressStartsWithHelp = `"set.addressStartsWith(prefix: string)" - lists ` +
                              `addresses whose names start with 'prefix'`;

const dataHelp = `"set.data(contract: string, method: string, args: any[])" - ` +
                 "displays tx data for contracts method with args";

const fetchingFromEtherscan = `Fetching recent txs for multisig wallet ` +
                              `${dependencyAddresses.TREASURY_MULTI_SIG[1]} from etherscan...`;

const listHeading = ` Tx   Description\n` +
                    `====  ===========  `;

// Errors
const unknownCommand = "*** Unknown command or missing arguments *** (See usage guide below.)\n\n";
const unknownTransaction = "*** Could not decode `view` command transaction number: ";
const unknownNum = "*** Unknown transaction number: ";
const reportAsBug = " Report this as a bug! ";
const comparePassed = chalk.green.bold("OK (data matches)");
const compareFailed = chalk.red.bold("FAILED (data doesn't match)\n");
const missingEtherscanApiKey = chalk.red("Please set an etherscan api key in the `.env` file.");

const noExecTransactionData = "*** Could not extract data from multisig tx payload ***\n" +
                                "Comparison works with data generated for " +
                                "`execTransaction(address to, uint256 value, bytes data,...)`";

const help = `Utility for viewing deferred production transaction data. Useful for comparing\n` +
             `tx data generated by multisig wallet with tx data generated by the deploy scripts.\n\n` +
             `USAGE: yarn tx <command> [args]\n\n` +
             `Commands:\n` +
             `  list:                    ${list}\n` +
             `  view <tx-num>:           ${view}\n` +
             `  compare <tx-num> <data>: ${compare}\n\n` +
             `Options:\n` +
             `  --file <descriptor>:     ${file}\n`;

// =============================
// Multisig Transaction ABI info
// =============================

const submitTxMethodId = "6a761202";
const submitTxMethodSig = "function execTransaction(address to, uint256 value, bytes data, " +
                          "uint8 operation, uint256 safeTxGas, uint256 dataGas, uint256 gasPrice, " +
                          "address gasToken, address refundReceiver, bytes signatures)";

// ====================
// `tx` Command Helpers
// ====================

/**
 * Sanity check variadic arguments passed to command
 */
function validateTaskArgs(taskArgs: any) {
  if (taskArgs.command === "list") {
    return true;
  }

  if (taskArgs.command === "view" && taskArgs.args.length === 1) {
    return true;
  }

  if (taskArgs.command === "compare" && taskArgs.args.length === 2) {
    return true;
  }

  if (taskArgs.command !== undefined) {
    log(unknownCommand);
  }

  log(help);
  return false;
}

function getTx(txs: any, txNum: string) {
  const tx = txs[txNum];

  if (tx === undefined || !tx.data) {
    log(unknownNum, txNum, " ***");
    process.exit(0);
  }

  return tx;
}

/**
 * Displays complete list of deferred transactions
 */
function listTxs(txs: any) {
  const txNumbers = Object.keys(txs).filter(num => (txs[num].id === null) ? true : false);
  log(listHeading);
  for (const number of txNumbers) {
    log(`${number.padEnd(5)} ${txs[number].description}`);
  }
}

/**
 * Displays decoded transaction data for a given transaction number
 */
function viewTx(txs: any, txNum: string, hre: HRE) {
  const tx = getTx(txs, txNum);
  const artifact = hre.artifacts.readArtifactSync(tx.contractName);
  const functions = new ethersABI.Interface(artifact.abi).functions;

  const txSig = tx.data.slice(2, 10);

  for (const key of Object.keys(functions)) {
    const raw = keccakFromString(key);
    const functionSig = bufferToHex(raw).slice(2, 10);
    if (functionSig == txSig) {
      const parsed = new ethersABI
        .Interface([`function ${key}`])
        .parseTransaction(tx) as any;

      const info = {
        args: parsed.args,
        signature: parsed.signature,
        data: tx.data,
      };

      log(tx.description);
      log("".padEnd(tx.description.length, "="));
      log(JSON.stringify(info, undefined, " "));
      return;
    }
  }

  log(unknownTransaction, txNum, reportAsBug, "***");
}

/**
 * Verifies that tx data generated locally by `saveDeferredTransaction` matches
 * what was generated for the Gnosis multisig UI. Logs OK if matched and
 * a colored string diff otherwise.
 */
function compareTx(txs: any, txNum: string, input: string) {
  const tx = getTx(txs, txNum);
  const extracted = extractExecTransactionData([{input}]);

  if (!extracted.length) {
    log(noExecTransactionData);
    return;
  }

  log(`${tx.description}\n` + "".padEnd(tx.description.length, "="));

  if (tx.data === extracted[0].data) {
    log(comparePassed);
  } else {
    const { ourData, theirData } = getDataDiff(tx.data, extracted[0].data);

    log(
      `${compareFailed}\n` +
      `Transaction "${txNum}" data:\n` +
      `  ${ourData}\n\n` +
      `Input data:\n` +
      `  ${theirData}\n`
    );
  }
}

/**
 * Generates a colorized diff for two bytecode strings
 */
function  getDataDiff(ours: string, theirs: string) {
  let ourData = "";
  let theirData = "";

  const dmp = new DiffMatchPatch();
  const diffResult = dmp.diff_main(ours, theirs);
  dmp.diff_cleanupSemantic(diffResult);

  for (const part of diffResult) {
    switch (part[0]) {
      case 0:
        ourData += part[1];
        theirData += part[1];
        continue;
      case -1:
        ourData += chalk.green(part[1]);
        continue;
      case 1:
        theirData += chalk.red(part[1]);
        continue;
    }
  }
  return {
    ourData,
    theirData,
  };
}

// ==========================
// `console` Command Helpers
// ==========================

/**
 * Gets a list of all public method signatures for `contractName`
 */
function getMethods(hre: HRE, contractName: string) {
  try {
    const artifact = hre.artifacts.readArtifactSync(contractName);
    const functions = new ethersABI.Interface(artifact.abi).functions;
    return Object.keys(functions).map(key => key);
  } catch (e) {
    log(e.message);
  }
}

/**
 * Generates transaction data for a `set.data(...)` console call.
 */
function getData(
  hre: HRE,
  methodName: string,
  args: any[]
) {
  try {
    const iface = new ethersABI.Interface([`function ${methodName}`]);
    const key = Object.keys(iface.functions)[0];
    return iface.encodeFunctionData(iface.functions[key].name, args);
  } catch (e) {
    log(e.message);
  }
}

/**
 * Gets a list of all system and dependency addresses and their human-reada ble aliases
 */
function getAllAddresses() {
  const addresses: any = {};

  Object.keys(systemAddresses)
    .filter(k => !(k.includes(" ") || k.includes("-")))
    .forEach(k => addresses[k] = systemAddresses[k]);

  Object.keys(dependencyAddresses).forEach(k => {
    if (typeof dependencyAddresses[k][1] === "string") {
      addresses[k] = dependencyAddresses[k][1];
    } else {
      addresses[k] = dependencyAddresses[k][1]["production"];
    }
  });

  return addresses;
}

/**
 * Gets a list of addresses filtered by `prefi x`
 */
function startsWith(prefix: string) {
  const addressMap: any = {};
  const addresses = getAllAddresses();
  Object
    .keys(addresses)
    .filter(k => k.toLowerCase().startsWith(prefix))
    .forEach(k => addressMap[k] = addresses[k]);
  return addressMap;
}

/**
 * Gets the human-readable alias for an address (if listed in 1-production or depedend encies)
 */
function getAddressName(val: string) {
  const addresses = getAllAddresses();
  const found = Object.keys(addresses).filter(k => addresses[k] === val).map(k => k);
  return (found.length) ? `${found[0]}` : "Not found";
}

/**
 * Extracts the `destination` address and `data` components from a Gnosis Safe
 * multisig wallet "execTransaction(address to, uint256 value, bytes data,...)" tx data string.
 */
function extractExecTransactionData(txs: any[]) {
   const data = [];
  for (const tx of txs) {
    if (tx .input?.slice(2, 10) === submitTxMethodId) {
      const parsed = new ethersABI
        .Interface([submitTxMethodSig])
        .parseTransaction({data: tx.input}) as any;

      data.push({
        txHash: tx.hash,
        timeStamp: (new Date(parseInt(`${tx.timeStamp}000`))).toString(),
        destination: parsed.args[0],
        data: parsed.args[2],
      });
    }
  }
  return data;
}

/**
 * Decodes an array of transaction data extracted from Gnosis
 * multisig transactions
 */
async function decodeTransactionData(hre: HRE, txs: any[]) {
  const decoded = [];
  destinationMap = await getDestinationMap(hre);

  for (const tx of txs ) {
    if (destinationMap[tx.destination]) {
      try {
        const parsed = new ethersABI
          .Interface(destinationMap[tx.destination].abi)
          .parseTransaction({data: tx.data}) as any;

        decoded.push({
          time: tx.timeStamp,
          txHash: tx.txHash,
          contract: destinationMap[tx.destination].contractName,
          method: parsed.signature,

          paramNames: Object
            .keys(parsed.args)
            .filter(k => parseInt(k) !== 0 && !parseInt(k) )
            .map(k => k),

          args: parsed.args.map((k: any) => (typeof k === "string") ? k : `${k}`),
        });
      } catch (e) {
        // ignore: sometimes ethers can't parse the data...
      }
    }
  }

  return decoded.reverse();
}

/**
 * Gets a map of contract addresses to contract names & abis, generated
 * from the `addresses` entry in `1 - production.json `
 */
function getDestinationMap(hre: HRE) {
  if (destinationMap) return destinationMap;

  destinationMap = {};

  for (const contractName of Object.keys(systemAddresses)) {
    let artifact;
    try {
      artifact = hre.artifacts.readArtifactSync(contractName);
    } catch (e) {
      // ignore deprecated addresses...
    }

    if (artifact) {
      destinationMap[systemAddresses[contractName]] = {
        contractName: contractName,
        abi: artifact.abi,
      };
    }
  }
  return destinationMap;
}

/**
 * Fetches a human-readable list of recent transactions from the Multisig wallet on
 * mainnet at `0xF8523c551763FE4261A28313015267F163de7541` from Etherscan
 */
async function getRecentMultisigTxs(hre: HRE, maxRecords?: number) {
  const max = (typeof maxRecords === "number") ? maxRecords : 25;

  const etherscanApiOptions = [
    "latest",  // startBlock
    undefined, // endBlock
    1,         // page
    max,       // max records to return
    "desc",    // sort (most recent, first)
  ];

  if (!hre.config.etherscan?.apiKey) {
    log(missingEtherscanApiKey);
    return;
  }

  log(fetchingFromEtherscan);

  const api = etherscan.init(hre.config.etherscan.apiKey);
  const txs = (await api.account.txlist(
    dependencyAddresses.TREASURY_MULTI_SIG[1],
    ...etherscanApiOptions
  )).result;

  const data = extractExecTransactionData(txs);
  return decodeTransactionData(hre, data);
}

// ====
// Task
// ====
task("set:utils:tx", help)
  .addOptionalPositionalParam("command", help)
  .addOptionalVariadicPositionalParam("args")
  .addOptionalParam("file", "", defaultFile)
  .setAction(async (taskArgs, hre: HRE) => {
    if (!validateTaskArgs(taskArgs)) return;

    const file = path.join(process.cwd(), `deployments/outputs/${taskArgs.file}.json`);
    const txs = require(file).transactions;

    switch (taskArgs.command) {
      case "list":    return listTxs(txs);
      case "view":    return viewTx(txs, taskArgs.args[0], hre);
      case "compare": return compareTx(txs, taskArgs.args[0], taskArgs.args[1]);
    }
  }
);

// ===========
// Environment
// ===========
extendEnvironment((hre: any) => {
  hre.set = {
    addresses: getAllAddresses(),
    addressStartsWith: (prefix: string) => startsWith(prefix),
    getAddressName: (address: string) => getAddressName(address),
    methods: (contractName: string) => getMethods(hre, contractName),
    data: (method: string, args: any[]) => getData(hre, method, args),
    recent: async (maxRecords?: number) => getRecentMultisigTxs(hre, maxRecords),
    help: {
      addresses: addressesHelp,
      addressStartsWith: addressStartsWithHelp,
      getAddressName: getAddressNameHelp,
      methods: methodsHelp,
      data: dataHelp,
      recent: recentHelp,
    },
  };
});

exports = {};
